grid,stackpanel,dockpanel,父类 panel；
button 父类 contentcontrol；

INotifyCollectionChanged;
INotifyPropertyChanged;

信号在UI树上传递的过程叫路由(Route);

属性其实是语法糖；


依赖属性:自己本身没有值，通过binding从数据源得到值，拥有依赖属性得对象叫依赖对象；

依赖属性得值是存储在hashtable里面的，在类里面只能有一个名为"Name"的CLR属性，所以在创建hashtable的
key值时，就是利用CLR属性"Name"和这个CLR属性所在的类的名字来做为key值得，对应得value值就是
DependencyProperty;

附加属性的作用就是将属性与数据类型(数组)解耦,让数据类型的设计更加灵活;

依赖属性用于支持数据绑定、样式、动画等高级功能，而附加属性用于向非依赖属性的对象添加额外的属性。

对于附加属性，使用方法来封装可以更好地控制属性的行为和使用方式。
附加属性的值是存储在对象的附加属性集合中的，因此可以使用方法来访问和修改该集合中的值。
使用方法封装可以使代码更加灵活和可扩展，可以根据需要添加额外的逻辑和行为。

附加属性binding的时候mode只能是单向；

多播:一个事件可以由多个事件处理器来响应；

路由事件的宿主都是些界面元素，而附加事件的不是；

CommandBinding只能绑定在外层的控件上，而不能绑定在窗口的DataContext中，是因为CommandBinding是一种控件级别的机制；

datatemplate对象是数据本身，但是数据最终呈现需要一个载体，这个载体一般是contentpresenter，contentpresenter只有一个
contenttemplate属性;

datatemplate如果设置了type，比如type是People，那界面上控件的数据如果是people类型，那就会展示成模板的样子;

LogicalTree是控件之间的逻辑关系，描述了控件之间的父子关系、兄弟关系等。例如，一个Window控件包含多个Button控件，这些Button控件就是Window控件的子控件，它们之间就构成了一个LogicalTree。

VisualTree是控件之间的视觉关系，描述了控件之间的布局关系、渲染关系等。例如，一个Button控件包含了一个Border控件和一个ContentPresenter控件，这些控件之间就构成了一个VisualTree

在MainWindow中设置UseLayoutRounding="True"可以解决Textbox添加了shadow之后，texbox里面内容变得模糊的问题；


ItemTemplate用于定义如何呈现数据项的外观和布局，它是一个DataTemplate对象，用于指定数据项的呈现方式。通过ItemTemplate，可以定义数据项的各个部分如何排列，如何使用绑定将数据项的属性值与控件的属性值关联起来，从而实现动态呈现数据项的功能。

ItemContainerStyle用于定义ItemsControl中每个子元素（即容器）的样式和行为，它是一个Style对象，用于指定容器元素的外观和行为。通过ItemContainerStyle，可以定义容器元素的样式、选择行为、焦点行为等。

DependencyProperty可以创建可读写的依赖属性；DependencyPropertyKey可以创建只读的依赖属性


VisualStateManager.GoToState(myControl, "Selected", true);